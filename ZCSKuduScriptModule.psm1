function RunKuduCommand
{
	Param(
		#Command to execute
		[parameter(Mandatory=$True)]
		[String]$Command,
		
		#Command execution directory
		[parameter(Mandatory=$True)]
		[String]$Directory,
		
		#Username to perform Kudu commands (Can be found in the MSDeploy publish profile of the webapp)
		[parameter(Mandatory=$True)]
		[String]$Username,
		
		#Password to perform Kudu commands (Can be found in the MSDeploy publish profile of the webapp)
		[parameter(Mandatory=$True)]
		[String]$Password,
		
		#Hostname to perform Kudu commands (Can be found in the MSDeploy publish profile of the webapp)
		[parameter(Mandatory=$True)]
		[String]$Hostname,
		
		#Reference parameter which will contain the return value of the Kudu Command
		[parameter(Mandatory=$True)]
		[ref]$Reference,
		
		#The ammount of retries of this command when execution failes
		[parameter(Mandatory=$False)]
		[Int]$RetryAmount = 10,
		
		#Timespan between command executions when retrying
		[parameter(Mandatory=$False)]
		[Int]$RetryTimespan = 60,
		
		#Suppress the errors generated by executing the command
		[parameter(Mandatory=$False)]
		[switch]$SuppressError = $False,	

		#Suppress the output generated by executing the command
		[parameter(Mandatory=$False)]
		[switch]$SuppressOutput = $False
	)
	
	#Create Base64 hash for Authorization header
	$Base64AuthInfo = [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes(("{0}:{1}" -f $Username,$Password)))
	
	#Create Body to post to restmethod
	$Body = "{'command': '$Command','dir':'$Directory'}"
	
	$Failed = $True
	$Retry = -1	
	do {
		$Exception = $False
		Write-Host "Executing Command with Kudu: $Command"
		Write-Host "Command execution directory: $Directory"
		
		try {
			$Output = Invoke-RestMethod -Uri "https://$Hostname/api/command" -Headers @{Authorization=("Basic {0}" -f $Base64AuthInfo)} -Method POST -Body $Body -ContentType "application/json" -TimeoutSec 1200
		}
		catch{ 
			$Exception = $True
			$result = $_.Exception.Response.GetResponseStream()
			$reader = New-Object System.IO.StreamReader($result)
			$responseBody = $reader.ReadToEnd();
			$responseMessage = $reader.ReadToEnd();
			$exceptionMessage = $_.Exception.Message;
		}	
		
		#Print output about exception
		if($Output.ExitCode -gt 0 -or $Exception -or ($Output.Error `
			-And (!($Output.Error.StartsWith("Already") -And $Command.StartsWith("git checkout")) 						<#Somehow the info about if a checkout is up to date already gets returned as an Error, don't handle as error#> `
			-And !($Output.Error.StartsWith("From") -And $Command.StartsWith("git fetch"))	 							<#Somehow the fetch info gets returned as an Error, don't handle as error#> `
			-And !($Output.Error.StartsWith("Everything up-to-date") -And $Command.StartsWith("git push"))	  			<#Somehow the push info gets returned as an Error, don't handle as error#> `
			-And !($Output.Error -Match "remote: Create pull request for" -And $Command.StartsWith("git push"))))){	  	<#Somehow the push info gets returned as an Error, don't handle as error#> `
			if(!([string]::IsNullOrEmpty($exceptionMessage))){
				Write-Host "!Exception: $($exceptionMessage)"}
			if(!([string]::IsNullOrEmpty($Output)) -And [string]::IsNullOrEmpty($Output.Output) -And [string]::IsNullOrEmpty($Output.Error)){
				Write-Host "!Output: $($Output)"}
			if(!([string]::IsNullOrEmpty($Output.Output))){
				Write-Host "!Output.Output: $($Output.Output)"}
			if(!([string]::IsNullOrEmpty($Output.Error))){
				Write-Host "!Error: $($Output.Error)"}
			if(!([string]::IsNullOrEmpty($Output.ExitCode))){
				Write-Host "!ExitCode: $($Output.ExitCode)"}
			if(!([string]::IsNullOrEmpty($responseBody))){
				Write-Host "!Exception: $($responseBody)"}
			if([string]::IsNullOrEmpty($exceptionMessage) -And [string]::IsNullOrEmpty($Output) -And [string]::IsNullOrEmpty($Output.Output) -And [string]::IsNullOrEmpty($Output.Error) -And [string]::IsNullOrEmpty($Output.ExitCode) -And [string]::IsNullOrEmpty($responseBody)){
				Write-Host "!Exception: No excpetion details"}				
		}
		else
		{
			if(!$SuppressOutput)
			{
				if(!([string]::IsNullOrEmpty($Output.Output))){
					Write-Host "Output: $($Output.Output)"}
				if(!([string]::IsNullOrEmpty($Output.Error))){
					Write-Host "Output: $($Output.Error)"}
				if([string]::IsNullOrEmpty($Output.Output) -And [string]::IsNullOrEmpty($Output.Error)){ 
					Write-Host "Output: [none]"}
			}
			
			$Failed = $False
			break
		}
		$Retry++
		
		if($RetryAmount -eq 0){
			Write-Host "Failed, no retries"
		} 
		elseif($Retry -lt $RetryAmount){
			$NewRetryIn = ($RetryTimespan * ($($Retry)+1))
			$UpcomingRetry = $Retry + 1
			Write-Host "Failed! Retry in $NewRetryIn sec, retry $UpcomingRetry of $RetryAmount"
			Start-Sleep -s $NewRetryIn
		}
		else{
			Write-Host "Failed! Retry $Retry of $RetryAmount"
		}
		
	} while($Retry -lt $RetryAmount)
	
	$Reference.value = $Output
	
	if($Failed)
	{
		if(!$SuppressError){
			throw "Something went wrong"
			exit 1
		}
		Write-Host "Suppressing errors..."
	}
}